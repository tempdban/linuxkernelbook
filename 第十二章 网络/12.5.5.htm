<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0066)http://www.kerneltravel.net/kernel-book/第十二章%20网络/12.5.5.htm -->
<HTML xmlns="http://www.w3.org/TR/REC-html40" xmlns:o = 
"urn:schemas-microsoft-com:office:office" xmlns:w = 
"urn:schemas-microsoft-com:office:word" xmlns:st1 = 
"urn:schemas-microsoft-com:office:smarttags"><HEAD><TITLE>支持函数</TITLE>
<META http-equiv=Content-Type content="text/html; charset=gb2312">
<META content=Word.Document name=ProgId>
<META content="MSHTML 6.00.3790.4324" name=GENERATOR>
<META content="Microsoft Word 11" name=Originator><LINK 
href="12.5.5.files/filelist.xml" rel=File-List><o:SmartTagType downloadurl="" 
name="chsdate" 
namespaceuri="urn:schemas-microsoft-com:office:smarttags"></o:SmartTagType><!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>CLJ</o:Author>
  <o:Template>Normal</o:Template>
  <o:LastAuthor>CLJ</o:LastAuthor>
  <o:Revision>2</o:Revision>
  <o:TotalTime>1</o:TotalTime>
  <o:Created>2007-08-17T14:37:00Z</o:Created>
  <o:LastSaved>2007-08-17T14:37:00Z</o:LastSaved>
  <o:Pages>1</o:Pages>
  <o:Words>543</o:Words>
  <o:Characters>3096</o:Characters>
  <o:Lines>25</o:Lines>
  <o:Paragraphs>7</o:Paragraphs>
  <o:CharactersWithSpaces>3632</o:CharactersWithSpaces>
  <o:Version>11.5606</o:Version>
 </o:DocumentProperties>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:GrammarState>Clean</w:GrammarState>
  <w:PunctuationKerning/>
  <w:DrawingGridVerticalSpacing>7.8 磅</w:DrawingGridVerticalSpacing>
  <w:DisplayHorizontalDrawingGridEvery>0</w:DisplayHorizontalDrawingGridEvery>
  <w:DisplayVerticalDrawingGridEvery>2</w:DisplayVerticalDrawingGridEvery>
  <w:ValidateAgainstSchemas/>
  <w:SaveIfXMLInvalid>false</w:SaveIfXMLInvalid>
  <w:IgnoreMixedContent>false</w:IgnoreMixedContent>
  <w:AlwaysShowPlaceholderText>false</w:AlwaysShowPlaceholderText>
  <w:Compatibility>
   <w:SpaceForUL/>
   <w:BalanceSingleByteDoubleByteWidth/>
   <w:DoNotLeaveBackslashAlone/>
   <w:ULTrailSpace/>
   <w:DoNotExpandShiftReturn/>
   <w:AdjustLineHeightInTable/>
   <w:BreakWrappedTables/>
   <w:SnapToGridInCell/>
   <w:WrapTextWithPunct/>
   <w:UseAsianBreakRules/>
   <w:DontGrowAutofit/>
   <w:UseFELayout/>
  </w:Compatibility>
  <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel>
 </w:WordDocument>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:LatentStyles DefLockedState="false" LatentStyleCount="156">
 </w:LatentStyles>
</xml><![endif]--><!--[if !mso]>
<OBJECT id=ieooui classid=clsid:38481807-CA0E-42D2-BF39-B33AF135CC4D></OBJECT>
<STYLE>st1\:* {
	BEHAVIOR: url(#ieooui)
}
</STYLE>
<![endif]-->
<STYLE>@font-face {
	font-family: 宋体;
}
@font-face {
	font-family: @宋体;
}
@page  {mso-page-border-surround-header: no; mso-page-border-surround-footer: no; }
@page Section1 {mso-layout-grid-char-alt: 0; size: 521.65pt 26.0cm; margin: 63.8pt 48.2pt 50.75pt 48.2pt; mso-header-margin: 46.8pt; mso-footer-margin: 49.6pt; mso-header: url("12.5.5.files/header.htm") h1; mso-footer: url("12.5.5.files/header.htm") f1; mso-paper-source: 0; layout-grid: 15.6pt 0pt; }
P.MsoNormal {
	TEXT-JUSTIFY: inter-ideograph; FONT-SIZE: 10.5pt; MARGIN: 0cm 0cm 0pt; FONT-FAMILY: "Times New Roman"; TEXT-ALIGN: justify; mso-style-parent: ""; mso-pagination: none; mso-bidi-font-size: 10.0pt; mso-fareast-font-family: 宋体; mso-font-kerning: 1.0pt
}
LI.MsoNormal {
	TEXT-JUSTIFY: inter-ideograph; FONT-SIZE: 10.5pt; MARGIN: 0cm 0cm 0pt; FONT-FAMILY: "Times New Roman"; TEXT-ALIGN: justify; mso-style-parent: ""; mso-pagination: none; mso-bidi-font-size: 10.0pt; mso-fareast-font-family: 宋体; mso-font-kerning: 1.0pt
}
DIV.MsoNormal {
	TEXT-JUSTIFY: inter-ideograph; FONT-SIZE: 10.5pt; MARGIN: 0cm 0cm 0pt; FONT-FAMILY: "Times New Roman"; TEXT-ALIGN: justify; mso-style-parent: ""; mso-pagination: none; mso-bidi-font-size: 10.0pt; mso-fareast-font-family: 宋体; mso-font-kerning: 1.0pt
}
SPAN.GramE {
	mso-style-name: ""; mso-gram-e: yes
}
DIV.Section1 {
	page: Section1
}
</STYLE>
<!--[if gte mso 10]>
<style>
 /* Style Definitions */
 table.MsoNormalTable
	{mso-style-name:普通表格;
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	mso-style-noshow:yes;
	mso-style-parent:"";
	mso-padding-alt:0cm 5.4pt 0cm 5.4pt;
	mso-para-margin:0cm;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-ansi-language:#0400;
	mso-fareast-language:#0400;
	mso-bidi-language:#0400;}
</style>
<![endif]--></HEAD>
<BODY lang=ZH-CN style="TEXT-JUSTIFY-TRIM: punctuation; tab-interval: 21.0pt">
<DIV class=Section1 
style="LAYOUT-GRID:  15.6pt 0pt; mso-layout-grid-char-alt: 0">
<P class=MsoNormal style="TEXT-ALIGN: left; mso-layout-grid-align: none" 
align=left><st1:chsdate w:st="on" IsROCDate="False" IsLunarDate="False" Day="30" 
Month="12" Year="1899"><B style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">12.5.5</SPAN></B></st1:chsdate><B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN></SPAN></B><B 
style="mso-bidi-font-weight: normal"><SPAN 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">支持函数</SPAN></B><SPAN 
lang=EN-US 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'"> 
<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 24pt; TEXT-ALIGN: left; mso-layout-grid-align: none" 
align=left><SPAN 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">每个网络驱动程序都提供了一系列非常实用的函数，这些函数都是底层的基本的函数；每个设备还包含了一组标准的例程，协议层可以将这些例程当作设备链路层的部分而调用。关于这些函数和例程，下面我们详细介绍。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 24pt; TEXT-ALIGN: left; mso-layout-grid-align: none" 
align=left><SPAN lang=EN-US 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'"><o:p>&nbsp;</o:p></SPAN></P>
<P class=MsoNormal style="TEXT-ALIGN: left; mso-layout-grid-align: none" 
align=left><B style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">1</SPAN></B><B 
style="mso-bidi-font-weight: normal"><SPAN 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">．初始化设置（<SPAN 
lang=EN-US>init)<o:p></o:p></SPAN></SPAN></B></P>
<P class=MsoNormal 
style="TEXT-INDENT: 24pt; TEXT-ALIGN: left; mso-layout-grid-align: none" 
align=left><B style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">init</SPAN></B><SPAN 
lang=EN-US 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'"> 
</SPAN><SPAN 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">函数在设备初始化和注册时被调用，它执行的是底层的确认和检查工作。在<SPAN 
lang=EN-US><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN></SPAN>初始化程序里你可以完成对硬件资源的配置。如果设备没有就绪或设备不能注册或其他任何原因而导致初始化工<SPAN 
class=GramE>作不能</SPAN>正常进行，该函数就返回出错信息。一旦初始化函数返回出错信息，<B 
style="mso-bidi-font-weight: normal"><SPAN 
lang=EN-US>register_netdev</SPAN>（）</B>也返回出错信息，这样该设备就不能安装。<SPAN lang=EN-US> 
<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 24pt; TEXT-ALIGN: left; mso-layout-grid-align: none" 
align=left><SPAN lang=EN-US 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'"><o:p>&nbsp;</o:p></SPAN></P>
<P class=MsoNormal style="TEXT-ALIGN: left; mso-layout-grid-align: none" 
align=left><B style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">2</SPAN></B><B 
style="mso-bidi-font-weight: normal"><SPAN 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">．打开<SPAN 
lang=EN-US><SPAN style="mso-spacerun: yes">&nbsp; </SPAN></SPAN>（<SPAN 
lang=EN-US> open</SPAN>）<SPAN lang=EN-US><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN></SPAN></SPAN></B><SPAN lang=EN-US 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 24pt; TEXT-ALIGN: left; mso-layout-grid-align: none" 
align=left><SPAN lang=EN-US 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'"><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN><B 
style="mso-bidi-font-weight: normal">open</B> </SPAN><SPAN 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">这个函数在网络设备驱动程序里是网络设备被激活的时候被调用<SPAN 
lang=EN-US>(</SPAN>即设备状<SPAN lang=EN-US><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN></SPAN><SPAN class=GramE>态由</SPAN><B 
style="mso-bidi-font-weight: normal"><SPAN 
lang=EN-US>down--&gt;up</SPAN></B><SPAN lang=EN-US>)</SPAN>。所以实际上很多在<B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US> init</SPAN></B><SPAN 
lang=EN-US> </SPAN>中的工作可以放到这里来做。比如资源的申请，硬件的激活。如果<B 
style="mso-bidi-font-weight: normal"><SPAN 
lang=EN-US>dev-&gt;open</SPAN></B><SPAN class=GramE>返回非零</SPAN><B 
style="mso-bidi-font-weight: normal"><SPAN 
lang=EN-US>(error)</SPAN></B>，则硬件的状态还是<B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US>down</SPAN></B>。<B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US> 
open</SPAN></B>函数另一个作用是如果驱动程序<SPAN 
class=GramE>做为</SPAN>一个模块被装入，则要防止模块卸载时设备处于打开状态。<SPAN lang=EN-US><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN></SPAN>在<B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US>open</SPAN></B>方法里要调用<SPAN 
lang=EN-US>MOD_INC_USE_COUNT</SPAN>宏。<SPAN lang=EN-US><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 24pt; TEXT-ALIGN: left; mso-layout-grid-align: none" 
align=left><SPAN lang=EN-US 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN>3</SPAN><SPAN 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">． 
<B style="mso-bidi-font-weight: normal">关闭<SPAN lang=EN-US><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN></SPAN>（<SPAN lang=EN-US> 
stop</SPAN>）</B><SPAN lang=EN-US><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 24pt; TEXT-ALIGN: left; mso-layout-grid-align: none" 
align=left><SPAN lang=EN-US 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">close </B></SPAN><SPAN 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">函数做和 
<B style="mso-bidi-font-weight: normal"><SPAN lang=EN-US>open 
</SPAN></B>函数相反的工作。可以释放某些资源以减少系统负担。<B style="mso-bidi-font-weight: normal"><SPAN 
lang=EN-US>close</SPAN></B>是在设备状态由<B style="mso-bidi-font-weight: normal"><SPAN 
lang=EN-US>up</SPAN></B>转为<B style="mso-bidi-font-weight: normal"><SPAN 
lang=EN-US>down</SPAN></B>时被调用的。另外如果是<SPAN class=GramE>做为</SPAN>模块装入的驱动程序，<B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US>close</SPAN></B>里应调用<SPAN 
lang=EN-US>MOD_DEC_USE_COUNT</SPAN>， 减少设备被引用的次数， 以使驱动程序可以被卸载。<SPAN 
lang=EN-US><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN></SPAN>另外<B 
style="mso-bidi-font-weight: normal"><SPAN 
lang=EN-US>close</SPAN></B>方法必须返回成功<SPAN lang=EN-US>(0==success)</SPAN>。<SPAN 
lang=EN-US><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 24pt; TEXT-ALIGN: left; mso-layout-grid-align: none" 
align=left><SPAN lang=EN-US 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'"><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN><o:p></o:p></SPAN></P>
<P class=MsoNormal style="TEXT-ALIGN: left; mso-layout-grid-align: none" 
align=left><B style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">4</SPAN></B><B 
style="mso-bidi-font-weight: normal"><SPAN 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">．数据帧传输例程<SPAN 
lang=EN-US> <o:p></o:p></SPAN></SPAN></B></P>
<P class=MsoNormal 
style="TEXT-INDENT: 24pt; TEXT-ALIGN: left; mso-layout-grid-align: none" 
align=left><SPAN 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">所有的设备驱动程序都必须提供传输例程，如果一个设备不能传输，也就没有存在的必要性。事实上，设备的所谓的传输仅仅是释放传送给它的缓冲区，而真正实现传输功能是虚拟设备。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 24pt; TEXT-ALIGN: left; mso-layout-grid-align: none" 
align=left><SPAN lang=EN-US 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'"><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN><B 
style="mso-bidi-font-weight: normal">dev-&gt;hard_start_xmit</B></SPAN><B 
style="mso-bidi-font-weight: normal"><SPAN 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">（）</SPAN></B><SPAN 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">：<B 
style="mso-bidi-font-weight: normal"> </B>该函数的功能是将网络缓冲区，也就是<B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US>sk_buff</SPAN></B><SPAN 
lang=EN-US> </SPAN>发送到硬件设备。如果设备不能接受缓冲区，它就会返回<SPAN lang=EN-US>1</SPAN>，并置 <B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN>dev-&gt;tbusy</SPAN></B><SPAN lang=EN-US> 
</SPAN><SPAN class=GramE>为非零值</SPAN>。这样缓冲区就排成队列，等待着<B 
style="mso-bidi-font-weight: normal"><SPAN 
lang=EN-US>dev-&gt;tbusy</SPAN></B><SPAN 
class=GramE>置零以后</SPAN>会再次发送。如果协议层决定释放<SPAN 
class=GramE>被设备</SPAN>抛弃的缓冲区，那么缓冲区就不会再被送回设备；如果设备知道缓冲区短时间内不被能传送，例如设备严重堵塞，那么它就调用<SPAN 
lang=EN-US><SPAN style="mso-spacerun: yes">&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">dev_kfree_skb</B></SPAN><B 
style="mso-bidi-font-weight: normal">（）</B>函数丢掉缓冲区，该函数返回零值标明缓冲区已经被处理完毕。<SPAN 
lang=EN-US> <o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 24pt; TEXT-ALIGN: left; mso-layout-grid-align: none" 
align=left><SPAN 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">当缓冲区被传送到硬件以后，硬件应答信号标识传输已经完毕，<SPAN 
lang=EN-US><SPAN style="mso-spacerun: yes">&nbsp; </SPAN></SPAN>驱动程序必须调用<B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US>dev_kfree_skb(skb, 
FREE_WRITE)</SPAN></B>函数释放缓冲区，一旦该调用结束，缓冲区就会很自然地消失，这样，驱动程序就不能<SPAN 
class=GramE>再涉及</SPAN>缓冲区了。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 24pt; TEXT-ALIGN: left; mso-layout-grid-align: none" 
align=left><SPAN 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">该函数传送下来的<B 
style="mso-bidi-font-weight: normal"><SPAN 
lang=EN-US>sk_buff</SPAN></B>中的数据已经包含硬件需要的帧头。所以在发送方法里不需要再填充硬件帧头，数据可以直接提交给硬件发送。<B 
style="mso-bidi-font-weight: normal"><SPAN 
lang=EN-US>sk_buff</SPAN></B>是被锁住的<SPAN lang=EN-US>(<B 
style="mso-bidi-font-weight: normal">locked</B>)</SPAN>，确保其他程序不会存取它。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-ALIGN: left; mso-layout-grid-align: none" 
align=left><SPAN lang=EN-US 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">5</SPAN><SPAN 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">．<B 
style="mso-bidi-font-weight: normal">硬件帧头<SPAN lang=EN-US> 
<o:p></o:p></SPAN></B></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 24pt; TEXT-ALIGN: left; mso-layout-grid-align: none" 
align=left><SPAN 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">前面我们讲过，数据帧在传送之前先要排成对列，在加入队列之前，还要在每个数据帧的开始添加硬件帧头，这项工作对于数据传送非常必要。网络设备驱动程序提供了一个<B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US>dev-&gt;hard_header( 
)</SPAN></B><SPAN lang=EN-US> </SPAN>例程，来完成添加<SPAN 
class=GramE>硬件帧头的</SPAN>工作。协议层在发送数据之前会在缓冲区的开始留下至少<B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US> dev-&gt;hard_header_len 
</SPAN></B>长度字节的空闲空间。这样<B style="mso-bidi-font-weight: normal"><SPAN 
lang=EN-US>dev-&gt;hard_header( )</SPAN></B><SPAN lang=EN-US> </SPAN>程序只要调用<B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US> 
skb_push</SPAN>（）</B>，然后正确填入<SPAN class=GramE>硬件帧头就</SPAN>可以了。<SPAN 
lang=EN-US><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 24pt; TEXT-ALIGN: left; mso-layout-grid-align: none" 
align=left><SPAN 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">调用这个例程需要给出和缓冲区相关的信息：设备指针、协议类型、指向源地址和目标地址（指硬件地址）的指针、数据包的长度。因为这个例程是在协议层发送函数触发之前被调用，所以一个非常重要参数值得我们注意：在这个例程中用的是<B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US> length 
</SPAN></B>参数，而不是用缓冲区的长度做参数，因为调用<B style="mso-bidi-font-weight: normal"><SPAN 
lang=EN-US>dev-&gt;hard_header( )</SPAN></B><SPAN 
class=GramE>时数据</SPAN>可能还没完<SPAN class=GramE>全组织</SPAN>好。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 24pt; TEXT-ALIGN: left; mso-layout-grid-align: none" 
align=left><SPAN lang=EN-US 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'"><o:p>&nbsp;</o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 24pt; TEXT-ALIGN: left; mso-layout-grid-align: none" 
align=left><SPAN 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">源地址可以为“<SPAN 
lang=EN-US>NULL</SPAN></SPAN><SPAN lang=EN-US 
style="COLOR: black; mso-font-kerning: 0pt; mso-ascii-font-family: 宋体">”</SPAN><SPAN 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">，这意味着“使用默认地址”；目标地址也可以为“<SPAN 
lang=EN-US>NULL</SPAN></SPAN><SPAN lang=EN-US 
style="COLOR: black; mso-font-kerning: 0pt; mso-ascii-font-family: 宋体">”</SPAN><SPAN 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">，这意味着“目标未知”。如果目标地址“未知”，数据帧头的操作就不能完成，本来为<SPAN 
class=GramE>硬件帧头预留</SPAN>的空间全部被其他信息占用，那么函数就返回填充硬件<SPAN 
class=GramE>帧头空间</SPAN>的字节数的相反数（一定为负数）。当<SPAN 
class=GramE>硬件帧头完全</SPAN>建立以后，函数返回所添加的数据帧头的字节数。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 24pt; TEXT-ALIGN: left; mso-layout-grid-align: none" 
align=left><SPAN lang=EN-US 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'"><o:p>&nbsp;</o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 24pt; TEXT-ALIGN: left; mso-layout-grid-align: none" 
align=left><SPAN 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">如果一个<SPAN 
class=GramE>硬件帧头不</SPAN>能够完全建立，协议层必须试图解决地址问题，因为硬件地址对于数据的发送是必需的。一旦这种情况发生，<B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US> dev-&gt;rebuild_header( ) 
</SPAN></B><SPAN lang=EN-US><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN></SPAN>函数就会被调用，通常是利用<SPAN 
lang=EN-US>ARP</SPAN>（地址解析协议）来完成。如果<SPAN 
class=GramE>硬件帧头还</SPAN>不能被解决，该函数就返回零，并且会再次尝试，协议<SPAN 
class=GramE>层总是</SPAN>相信<SPAN class=GramE>硬件帧头的</SPAN>解决是可能的。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-ALIGN: left; mso-layout-grid-align: none" 
align=left><B style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">6</SPAN></B><B 
style="mso-bidi-font-weight: normal"><SPAN 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">．数据接收　</SPAN></B><B 
style="mso-bidi-font-weight: normal"><SPAN 
style="COLOR: red; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">　<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></B></P>
<P class=MsoNormal 
style="TEXT-INDENT: 24pt; TEXT-ALIGN: left; mso-layout-grid-align: none" 
align=left><SPAN 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">网络设备驱动程序没有关于接收的处理，当数据到来时，总是驱动程序通知系统。对一个典型的网络设备，当它收到数据后都会产生一个中断，中断处理程序调用 
<B style="mso-bidi-font-weight: normal"><SPAN 
lang=EN-US>dev_alloc_skb</SPAN>（）</B>，申请一个大小合适的缓冲区（<B 
style="mso-bidi-font-weight: normal"><SPAN 
lang=EN-US>sk_buff</SPAN></B>），把从硬件传来的数据放入缓冲区。接着，设备驱动程序分析数据包的类型，把<B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US> 
skb-&gt;dev</SPAN></B>设置为接收数据的设备类型<B style="mso-bidi-font-weight: normal"> 
</B>，把<B style="mso-bidi-font-weight: normal"><SPAN lang=EN-US> 
skb-&gt;protocol</SPAN></B><SPAN lang=EN-US> 
</SPAN>设置为数据帧描述的协议类型，这样，数据帧就可以被发送到正确的协议层。<SPAN class=GramE>硬件帧头指针</SPAN>保存在 <B 
style="mso-bidi-font-weight: normal"><SPAN 
lang=EN-US>skb-&gt;mac.raw</SPAN></B>中，并且<SPAN class=GramE>硬件帧头通过</SPAN>调用<B 
style="mso-bidi-font-weight: normal"><SPAN 
lang=EN-US>skb_pull</SPAN>（）</B>被去掉，因此网络协议就不涉及硬件的信息。最后</SPAN><SPAN 
style="COLOR: red; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'"> 
</SPAN><SPAN 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">还要设置<B 
style="mso-bidi-font-weight: normal"><SPAN 
lang=EN-US>skb-&gt;pkt_type</SPAN></B>，标明链路层数据类型，设备驱动程序必须按以下类型设置 <B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US>skb-&gt;pkt_type 
</SPAN>：<SPAN lang=EN-US><o:p></o:p></SPAN></B></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 24pt; TEXT-ALIGN: left; mso-layout-grid-align: none" 
align=left><B style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'"><o:p>&nbsp;</o:p></SPAN></B></P>
<P class=MsoNormal 
style="TEXT-INDENT: 24pt; TEXT-ALIGN: left; mso-layout-grid-align: none" 
align=left><SPAN lang=EN-US 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">PACKET_BROADCAST<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN></SPAN><SPAN 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">链接层广播地址　　<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 24pt; TEXT-ALIGN: left; mso-layout-grid-align: none" 
align=left><SPAN lang=EN-US 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">PACKET_MULTICAST<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN></SPAN><SPAN 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">链接层多路地址　　</SPAN><SPAN 
class=GramE><SPAN 
style="COLOR: red; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">　</SPAN></SPAN><SPAN 
lang=EN-US 
style="COLOR: red; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'"><o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 24pt; TEXT-ALIGN: left; mso-layout-grid-align: none; tab-stops: 138.3pt" 
align=left><SPAN lang=EN-US 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">PACKET_SELF<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN></SPAN><SPAN lang=EN-US 
style="COLOR: red; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'"><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN></SPAN><SPAN lang=EN-US 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN></SPAN><SPAN 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">发给自己的数据帧　　<SPAN 
class=GramE>　</SPAN><SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 24pt; TEXT-ALIGN: left; mso-layout-grid-align: none" 
align=left><SPAN lang=EN-US 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">PACKET_OTHERHOST<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN></SPAN><SPAN 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">发向另一个主机的数据帧 
（监听模式时会有到）</SPAN><SPAN 
style="COLOR: red; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">　<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 24pt; TEXT-ALIGN: left; mso-layout-grid-align: none" 
align=left><SPAN lang=EN-US 
style="COLOR: red; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'"><o:p>&nbsp;</o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 24pt; TEXT-ALIGN: left; mso-layout-grid-align: none" 
align=left><SPAN lang=EN-US 
style="COLOR: red; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'"><o:p>&nbsp;</o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 24pt; TEXT-ALIGN: left; mso-layout-grid-align: none" 
align=left><SPAN 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">最后，设备驱动程序调用</SPAN><SPAN 
style="COLOR: red; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'"> 
</SPAN><B style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">netif_rx( 
)</SPAN></B><SPAN 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">（见图<st1:chsdate 
w:st="on" IsROCDate="False" IsLunarDate="False" Day="30" Month="12" 
Year="1899"><SPAN lang=EN-US>12.4.1</SPAN></st1:chsdate>）把缓冲区向上传递<SPAN 
class=GramE>给协议层</SPAN>。</SPAN><SPAN 
style="COLOR: red; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'"> 
</SPAN><SPAN 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">缓冲区首先排成一个队列，然后发出中断请求，中断请求响应后，缓冲区队列才<SPAN 
class=GramE>被协议层</SPAN>进行处理。这种处理机制，延长了缓冲区等待处理的时间，但是减少了请求中断的次数，从而整体上提高了数据传输效率。一旦<B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>netif_rx( )</SPAN></B>被调用，缓冲区就<SPAN 
class=GramE>不在属</SPAN>设备驱动程序所有，它不能被修改，而且设备驱动程序也不能<SPAN 
class=GramE>再涉及</SPAN>它了。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 24pt; TEXT-ALIGN: left; mso-layout-grid-align: none" 
align=left><SPAN lang=EN-US 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'"><o:p>&nbsp;</o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 24pt; TEXT-ALIGN: left; mso-layout-grid-align: none" 
align=left><SPAN 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">在协议层，接收数据包的流程控制分两个层次：</SPAN><SPAN 
style="COLOR: red; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'"> 
</SPAN><SPAN 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">首先，<B 
style="mso-bidi-font-weight: normal"><SPAN 
lang=EN-US>netif_rx</SPAN>（）</B>函数限制了从物理层到协议层的数据帧的数量。第二，每一个套接字都有一个队列，限制从协议层到<SPAN 
class=GramE>套接字层的</SPAN>数据帧的数量。在传输方面，驱动程序的 <B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US>dev-&gt;tx_queue_len 
</SPAN></B>参数用来限制队列的长度。队列的长度通常是<SPAN 
lang=EN-US>100</SPAN>帧，在进行大量数据传输的高速连接中，它足以容纳下所有等待传输的缓冲区，不会出现大量缓冲区阻塞的情况。在低速连接中，例如<SPAN 
lang=EN-US>Slip </SPAN>连接，队列的长度长设为<SPAN lang=EN-US>10</SPAN>帧左右，因为传输<SPAN 
lang=EN-US>10</SPAN>帧的数据就要花费数秒的时间排列数据。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-ALIGN: left; mso-layout-grid-align: none" 
align=left><B style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="FONT-SIZE: 12pt; COLOR: black; FONT-FAMILY: 宋体; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">12.6<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN></SPAN></B><B 
style="mso-bidi-font-weight: normal"><SPAN 
style="FONT-SIZE: 12pt; COLOR: black; FONT-FAMILY: 宋体; mso-bidi-font-size: 10.0pt; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">本章小结<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></B></P>
<P class=MsoNormal 
style="TEXT-INDENT: 24pt; TEXT-ALIGN: left; mso-layout-grid-align: none" 
align=left><SPAN 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">本章的主要目的是介绍<SPAN 
lang=EN-US>Linux</SPAN>操作系统网络部分的基本工作原理。因为<SPAN 
lang=EN-US>Linux</SPAN>支持多种协议类型和多种网络设备，加上网络部分本身就比较复杂，所以本章所涉及的内容十分有限。为了便于说明，采用了以点带面的方法，着重介绍了网络部分的四个核心对象。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 24pt; TEXT-ALIGN: left; mso-layout-grid-align: none" 
align=left><SPAN 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">本章首先介绍了<SPAN 
lang=EN-US>Linux</SPAN>网络部分源代码的面向对象设计思想，指出了四个核心对象：<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 24pt; TEXT-ALIGN: left; mso-layout-grid-align: none" 
align=left><SPAN 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">・网络协议<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 24pt; TEXT-ALIGN: left; mso-layout-grid-align: none" 
align=left><SPAN 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">・套接字<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 24pt; TEXT-ALIGN: left; mso-layout-grid-align: none" 
align=left><SPAN 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">・套接字缓冲区<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 24pt; TEXT-ALIGN: left; mso-layout-grid-align: none" 
align=left><SPAN 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">・网络设备接口<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 24pt; TEXT-ALIGN: left; mso-layout-grid-align: none" 
align=left><SPAN 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">随后，用面向对象的分析方法，分别介绍了这四个核心对象的相关内容和它们之间的关系，这对于理解<SPAN 
lang=EN-US>Linux</SPAN>网络的工作原理有很大帮助。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 24pt; TEXT-ALIGN: left; mso-layout-grid-align: none" 
align=left><SPAN 
style="COLOR: black; FONT-FAMILY: 宋体; mso-font-kerning: 0pt; mso-hansi-font-family: 'Times New Roman'">关于内容，本章尽可能详细具体，贴近实际应用，对于和实际应用有关系的地方都做了深入介绍。如果读者要做网络编程，请参考<SPAN 
lang=EN-US>12.2</SPAN>网络协议，<SPAN lang=EN-US>12.3</SPAN>套接字，<SPAN 
lang=EN-US>12.<SPAN class=GramE>4<SPAN lang=EN-US><SPAN 
lang=EN-US>套接字缓冲区</SPAN></SPAN></SPAN></SPAN>三节；如果要编写网络驱动程序，请参考<SPAN 
lang=EN-US>12.<SPAN class=GramE>4<SPAN lang=EN-US><SPAN 
lang=EN-US>套接字缓冲区</SPAN></SPAN></SPAN></SPAN>和<SPAN 
lang=EN-US>12.5</SPAN>网络设备接口两节。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal><SPAN 
lang=EN-US><o:p>&nbsp;</o:p></SPAN></P></DIV></BODY></HTML>
